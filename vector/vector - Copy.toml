# 1) Source: all matching log files
[sources.am_logs]
type  = "file"
include = [
  "/data/logs/am.log*",
  "/data/logs/gc.log*",
  "/data/logs/SoftTokenExt.log*",
  "/data/logs/SoftTokenWs.log*",
  "/data/logs/YESsafeToken.log*"
]
exclude = ["/data/logs/desktop"]
read_from = "beginning"

# 2) Throttle to protect memory/CPU
[transforms.logs_throttled]
type = "throttle"
inputs = ["am_logs"]
threshold = 1000
window_secs = 10
key_field = "file"

# 3) Branch A — AM‑style log parser
[transforms.parse_am]
type   = "remap"
inputs = ["logs_throttled"]
source = '''
.file_path = .file
.raw = to_string(.message) ?? to_string(.) ?? ""

if match!(.file, r'.*am\.log.*|SoftToken.*|YESsafe.*') {
  am, am_err = parse_regex(.raw, r'^(?P<ts>\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\.\d{3})\s+

\[(?P<thr>[^\]

]+)\]

\s+(?P<lvl>[A-Z]+)\s+-+\s+\((?P<cls>[^:]+)(?::(?P<line>\d+))?\)\s+(?P<msg>.*)$')
  if am_err == null {
    .timestamp = am.ts
    .thread    = am.thr
    .level     = am.lvl
    .class     = am.cls
    if exists(am.line) { .line = to_int!(am.line) }
    .message   = am.msg
    .text      = .message
  } else {
    .level   = "unparsed"
    .message = .raw
    .text    = .raw
  }
}
'''


[transforms.parse_gc]
type   = "remap"
inputs = ["logs_throttled"]
source = '''
.file_path = .file
.raw = to_string(.message) ?? to_string(.) ?? ""

if match!(.file, r'.*gc\.log.*') {
  gc, gc_err = parse_regex(.raw, r'^

\[(?P<uptime>[0-9\.]+s)\]



\[(?P<level>[a-z]+)\]



\[(?P<category>[^\]

]+)\]

\s+(?P<msg>.*)$')
  if gc_err == null {
    .uptime   = gc.uptime
    .level    = gc.level
    .category = strip_whitespace!(gc.category)
    .message  = gc.msg
    .text     = .message
  } else {
    .level   = "unparsed"
    .message = .raw
    .text    = .raw
  }
}
'''

[sinks.jsonl]
type           = "file"
inputs         = ["parse_am", "parse_gc"]
path           = "/data/clean/parsed.jsonl"
encoding.codec = "json"

[sinks.metrics_console]
type   = "console"
inputs = ["logs_throttled"]
encoding.codec = "json"

[sinks.dev_console]
type   = "console"
inputs = ["parse_am", "parse_gc"]
encoding.codec = "json"
